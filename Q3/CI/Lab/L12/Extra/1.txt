/* Main.c file generated by New Project wizard
 *
 * Created:   Mon Dec 21 2020
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */


#include <xc.h>
#define _XTAL_FREQ 8000000 
#define PINA0 PORTAbits.RA0
#define PINA1 PORTAbits.RA1

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "config.h"
#include "GLCD.h"
#include "splash.h"
#include "ascii.h"

#define GO_DONE ADCON0bits.GO

int status_old = 0;
int status_new = 0;

unsigned int IntroOver = 0;
char StartGame = 0;
unsigned char s[6] = "Ricard";
const char * c = "#";
const char * v = "$";

int seed = 4;
int PosXPICs[20];
int PosYPICs[20] = 0;
int actualPics = 1;
int old_difficulty = 1;
int new_difficulty = 1;

int pic_generated;
int generate_pic = 0;
int pic_movement;
int move_pic = 0;

char posX = 5;
int YesNo = 0;
char END = 0;

int PrePts = 0, PostPts = 0;
int PreLives = 3, PostLives = 3;

void pics_generator(int j) {
   clearGLCD(PosYPICs[j],PosYPICs[j],PosXPICs[j],5+(PosXPICs[j])*5);
   PosYPICs[j] = PosYPICs[j] + 1;
   if(PosXPICs[j] == posX && PosYPICs[j] == 7){ 
      PosXPICs[j] = -1;
      PosYPICs[j] = -1;
      //--actualPics;
      PostPts++;
   } else if(PosYPICs[j] == 7) {
      PosXPICs[j] = -1;
      PosYPICs[j] = -1;
      //--actualPics;
      --PostLives;
   } else writeTxt(PosYPICs[j],PosXPICs[j],v);
   generate_pic = 0;
}

void pics_movements() {
   ++YesNo;
   if(new_difficulty == 1 && YesNo == 3) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   } else if(new_difficulty == 2 && YesNo == 2) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   } else if(new_difficulty == 3 && YesNo == 3) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   } else if(new_difficulty == 4 && YesNo == 2) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   }
   move_pic = 0;
}

void interrupt HighInt(void) {
   if(INTCONbits.TMR0IE && INTCONbits.TMR0IF && PostLives > 0 && !END) {
      INTCONbits.TMR0IF=0;
      if(StartGame == 0) {
	 IntroOver = 1;
	 StartGame = 1;
      } else {
	 move_pic = 1;
      }
   }
   if(PIE1bits.TMR2IE && PIR1bits.TMR2IF && StartGame && PostLives > 0 && !END){
      for (int j=0;j<=actualPics;j++) {
	 if(PosXPICs[j] != -1 && PosYPICs[j] != 0){
	    generate_pic = 1;
	    pic_generated = j;
	    move_pic = 1;
	 }
      }
   }
}

void printData(){
   if(PrePts != PostPts) writeNum(0,5,PostPts);
   if(PreLives != PostLives || PostLives == 3) {
      int i = 1, j = 2;
      if(PostLives == 3) {
	 while(i <= 3) {
	 putchGLCD(0,18+j,126);
	 j = j+2;
	 ++i;
	 }
      } else if (PostLives == 2) {
	 clearGLCD(0,0,120,126);
      } else if (PostLives == 1) {
	 clearGLCD(0,0,110,122);
      } else {
	 clearGLCD(0,0,100,110);
	 __delay_ms(250); 
	 clearGLCD(0,7,0,127);
	 writeTxt(5,8, "PICs Collected");
	 writeTxt(3,7,"Game Over!");
	 writeNum(5,5,PostPts);
   
	 END = 1;
      }
   }
}

void player_movements() {
   if(PINA0 == 1 && posX < 24){
      clearGLCD(7,7,posX,5+posX*5);
      ++posX;
      writeTxt(7,posX,c);	
      __delay_ms(250); 
   } else if(PINA1 == 1 && posX > 0){
      clearGLCD(7,7,posX,5+posX*5);
      --posX;
      writeTxt(7,posX,c);
      __delay_ms(250);
   }
}

void calc_difficulty(int value) {
   if(value < 300) {
      new_difficulty = 1;
      TMR0=18661;		//3 s 
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
   } else if (value > 300 && value < 550) {
      new_difficulty = 2;
      TMR0=18661;		//3 s
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
   } else if (value > 550 && value < 800) {
      new_difficulty = 3;
      TMR0=3036;		//1 s
      T0CONbits.T0PS=0b100;	//prescaler = 32 -> 46875 < 2^16 //0b110
   } else if (value > 800) {
      new_difficulty = 4;
      TMR0=3036;		//0.5 s
      T0CONbits.T0PS=0b011;	//prescaler = 16-> 46875 < 2^16 //0b110
   }
   if(new_difficulty != old_difficulty) {
      old_difficulty = new_difficulty;
      writeNum(0,11,new_difficulty);
   }
}

void check_AD() {
   GO_DONE = 1;
   while(GO_DONE) {
      status_old = status_new;
      status_new = ADRESH*256 + ADRESL;
      if(status_old != status_new) calc_difficulty(status_new);
   }
}

void pics_management() {
   if(generate_pic == 1) {
      pics_generator(pic_generated);
   }
   if(move_pic == 1) {
      pics_movements();
   }
}

void Game() { 
   check_AD();
   printData();
   player_movements();
   pics_management();
}


void initialize_game() {
   T0CONbits.TMR0ON = 1;  	//TMR0 ON
   T2CONbits.TMR2ON = 1;  	//TMR2 ON
   writeTxt(0,0," Pts:");
   writeTxt(0,13, "Lives:");
   writeTxt(0,7,"Dif:");
   writeNum(0,5,PostPts);
   writeNum(0,11,new_difficulty);
   writeTxt(7,posX,c);	
   PosYPICs[0] = 1;
   PosXPICs[0] = rand() % 24;
   writeTxt(PosYPICs[0],PosXPICs[0], v);
}

void putc_usart1(char xc) {
   while(!PIR1bits.TX1IF);
   TXREG1 = xc;
}

void puts_usart1(unsigned char *cptr) {
   while(*cptr) {
      putc_usart1(*cptr++);
   }
}

void welcome() {
   for(int i = 0; i < 8; ++i) {
      for(int j = 0; j < 128; ++j) {
	 writeByte(i, j, bitmap[i * 128 + j]);
      }
   }
}


void configPIC() {
   
      ANSELD = 0;               //PORTD configurat com Digital
      ANSELB = 0;		//PORTB configurat com Digital
      ANSELC = 0;		//PORTC Digital
      ANSELA = 0;
   
      PORTD = 0;
      PORTB = 0; 
      PORTA = 0; 

      TRISA = 0x07;
      TRISD = 0x00;		
      TRISB = 0x00;
   
      INTCONbits.GIEH=0;	//Val 0 pq inicialment no s'ha de cridar a la rsi(degut status init)
      INTCONbits.TMR0IF=0;
      INTCONbits.TMR0IE=1; 	//TMR0 enabled
      INTCON2bits.TMR0IP=1; 	//TMR0 Prio enabled (TMR0 always highPrio)
      TMR0=18661;		//2^16 - 46875 (preescaler = 128)
   
  
      T0CONbits.TMR0ON=0;  	//TMR0 OFF
      T0CONbits.T08BIT=0;  	//TMR0 16bits
      T0CONbits.T0CS=0;    	//fosc/4
      T0CONbits.PSA=0;		//prescaler on
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
      
      PR2 = 3036;
      T2CON=0x2B; 		//PRE = 16, POST = 6 --> 3*(1/(16*6)/2x10^6)) = 62500 < 2^16 //2B
      IPR1bits.TMR2IP = 1;
      PIE1bits.TMR2IE = 1;
      PIR1bits.TMR2IF = 0;
      
      /*
      PR2=256;
      T2CON=0xFF;
      IPR1bits.TMR2IP = 0;
      PIE1bits.TMR2IE = 1;
      PIR1bits.TMR2IF = 0;
      */

      ADCON0 = 0x09;
      ADCON1 = 0x00;
      ADCON2 = 0b10100100;
}




void configUSART() {
      /*
      TRISCbits.RC6 = 0;	// Configurem RC6 de sortida (transmissió)
      TRISCbits.RC7 = 1;	// Configurem RC7 d'entrada (recepció)
   
      TXSTA1bits.TX9 = 0;
      TXSTA1bits.SYNC = 0;
      TXSTA1bits.BRGH = 1;
      BAUDCON1bits.BRG16 = 0;
      SPBRG1 = 16;
      TXSTA1bits.TXEN = 1;
      RCSTA1bits.RX9 = 0;
      RCSTA1bits.SREN = 1;
      RCSTA1bits.SPEN = 1;
      */
   
      SPBRG1 =3;
      TXSTA1bits.BRGH = 1;
      TXSTA1bits.TX9 = 0;
      TXSTA1bits.TXEN = 1;
      RCSTA1bits.SREN = 1;
      RCSTA1bits.SPEN = 1;
      RCSTA1bits.RX9 = 0;
      BAUDCON1bits.BRG16 = 1;
      TRISC = 0xFF;
      PIE1bits.RC1IE = 1;
      IPR1bits.RC1IP = 1;
      TXSTA1bits.SYNC = 0;
      RCSTA1bits.CREN = 1;
}

void main(void) {
   configPIC();
   //configUSART();
   
   GLCDinit();
   clearGLCD(0,7,0,127);
   setStartLine(0);
   welcome();
   INTCONbits.GIEH=1;
   T0CONbits.TMR0ON=1;  		//TMR0 ON
   //puts_usart1(s);
   while (1) {
      if(IntroOver == 1) {
	 IntroOver = 0;
	 clearGLCD(0,7,0,127);
	 setStartLine(0);
	 initialize_game();
      }
      if(StartGame == 1) {
	 Game();
      }
   }
}










/* Main.c file generated by New Project wizard
 *
 * Created:   Mon Dec 21 2020
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */


#include <xc.h>
#define _XTAL_FREQ 8000000 
#define PINA0 PORTAbits.RA0
#define PINA1 PORTAbits.RA1

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "config.h"
#include "GLCD.h"
#include "splash.h"
#include "ascii.h"

#define GO_DONE ADCON0bits.GO

int status_old = 0;
int status_new = 0;

unsigned int IntroOver = 0;
char StartGame = 0;
unsigned char s[6] = "Ricard";
const char * c = "#";
const char * v = "$";

int seed = 4;
int PosXPICs[20];
int PosYPICs[20] = 0;
int actualPics = 1;
int old_difficulty = 1;
int new_difficulty = 1;

char posX = 5;
int YesNo = 0;
char END = 0;

int PrePts = 0, PostPts = 0;
int PreLives = 3, PostLives = 3;

void interrupt HighInt(void) {
   if(INTCONbits.TMR0IE && INTCONbits.TMR0IF && PostLives > 0 && !END) {
      INTCONbits.TMR0IF=0;
      if(StartGame == 0) {
	 IntroOver = 1;
	 StartGame = 1;
      } else {
	 ++YesNo;
	 if(new_difficulty == 1 && YesNo == 3) {
	    YesNo = 0;
	    ++actualPics;
	    if(PosYPICs[actualPics] == 0) {
	       PosYPICs[actualPics] = 1;
	       PosXPICs[actualPics] = rand() % 24;
	       writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
	    }
	 } else if(new_difficulty == 2 && YesNo == 2) {
	    YesNo = 0;
	    ++actualPics;
	    if(PosYPICs[actualPics] == 0) {
	       PosYPICs[actualPics] = 1;
	       PosXPICs[actualPics] = rand() % 24;
	       writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
	    }
	 } else if(new_difficulty == 3 && YesNo == 3) {
	    YesNo = 0;
	    ++actualPics;
	    if(PosYPICs[actualPics] == 0) {
	       PosYPICs[actualPics] = 1;
	       PosXPICs[actualPics] = rand() % 25;
	       writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
	    }
	 } else if(new_difficulty == 4 && YesNo == 2) {
	    YesNo = 0;
	    ++actualPics;
	    if(PosYPICs[actualPics] == 0) {
	       PosYPICs[actualPics] = 1;
	       PosXPICs[actualPics] = rand() % 25;
	       writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
	    }
	 }
      }
   }
   if(PIE1bits.TMR2IE && PIR1bits.TMR2IF && StartGame && PostLives > 0 && !END){
      for (int j=0;j<=actualPics;j++) {
	 if(PosXPICs[j] != -1 && PosYPICs[j] != 0){
	    clearGLCD(PosYPICs[j],PosYPICs[j],PosXPICs[j],5+(PosXPICs[j])*5);
	    PosYPICs[j] = PosYPICs[j] + 1;
	    if(PosXPICs[j] == posX && PosYPICs[j] == 7){ 
		PosXPICs[j] = -1;
		PosYPICs[j] = -1;
		//--actualPics;
		PostPts++;
	    } else if(PosYPICs[j] == 7) {
		PosXPICs[j] = -1;
		PosYPICs[j] = -1;
		//--actualPics;
		--PostLives;
	    } else {
		writeTxt(PosYPICs[j],PosXPICs[j],v);
	    }
	 }
      }	 
   }
}

void printData(){
   if(PrePts != PostPts) writeNum(0,5,PostPts);
   if(PreLives != PostLives || PostLives == 3) {
      int i = 1, j = 2;
      if(PostLives == 3) {
	 while(i <= 3) {
	 putchGLCD(0,18+j,126);
	 j = j+2;
	 ++i;
	 }
      } else if (PostLives == 2) {
	 clearGLCD(0,0,120,126);
      } else if (PostLives == 1) {
	 clearGLCD(0,0,110,122);
      } else {
	 clearGLCD(0,0,100,110);
	 __delay_ms(250); 
	 clearGLCD(0,7,0,127);
	 writeTxt(5,8, "PICs Collected");
	 writeTxt(3,7,"Game Over!");
	 writeNum(5,5,PostPts);
   
	 END = 1;
      }
   }
}

void player_movements() {
   if(PINA0 == 1 && posX < 24){
      clearGLCD(7,7,posX,5+posX*5);
      ++posX;
      writeTxt(7,posX,c);	
      __delay_ms(250); 
   } else if(PINA1 == 1 && posX > 0){
      clearGLCD(7,7,posX,5+posX*5);
      --posX;
      writeTxt(7,posX,c);
      __delay_ms(250);
   }
}

void calc_difficulty(int value) {
   if(value < 300) {
      new_difficulty = 1;
      TMR0=18661;		//3 s 
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
   } else if (value > 300 && value < 550) {
      new_difficulty = 2;
      TMR0=18661;		//3 s
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
   } else if (value > 550 && value < 800) {
      new_difficulty = 3;
      TMR0=3036;		//1 s
      T0CONbits.T0PS=0b100;	//prescaler = 32 -> 46875 < 2^16 //0b110
   } else if (value > 800) {
      new_difficulty = 4;
      TMR0=3036;		//0.5 s
      T0CONbits.T0PS=0b011;	//prescaler = 16-> 46875 < 2^16 //0b110
   }
   if(new_difficulty != old_difficulty) {
      old_difficulty = new_difficulty;
      writeNum(0,11,new_difficulty);
   }
}

void check_AD() {
   GO_DONE = 1;
   while(GO_DONE) {
      status_old = status_new;
      status_new = ADRESH*256 + ADRESL;
      if(status_old != status_new) calc_difficulty(status_new);
   }
}

void Game() { 
   check_AD();
   printData();
   check_AD();
   player_movements();
   check_AD();
}


void initialize_game() {
   T0CONbits.TMR0ON = 1;  	//TMR0 ON
   T2CONbits.TMR2ON = 1;  	//TMR2 ON
   writeTxt(0,0," Pts:");
   writeTxt(0,13, "Lives:");
   writeTxt(0,7,"Dif:");
   writeNum(0,5,PostPts);
   writeNum(0,11,new_difficulty);
   writeTxt(7,posX,c);	
   PosYPICs[0] = 1;
   PosXPICs[0] = rand() % 24;
   writeTxt(PosYPICs[0],PosXPICs[0], v);
}

void putc_usart1(char xc) {
   while(!PIR1bits.TX1IF);
   TXREG1 = xc;
}

void puts_usart1(unsigned char *cptr) {
   while(*cptr) {
      putc_usart1(*cptr++);
   }
}

void welcome() {
   for(int i = 0; i < 8; ++i) {
      for(int j = 0; j < 128; ++j) {
	 writeByte(i, j, bitmap[i * 128 + j]);
      }
   }
}


void configPIC() {
   
      ANSELD = 0;               //PORTD configurat com Digital
      ANSELB = 0;		//PORTB configurat com Digital
      ANSELC = 0;		//PORTC Digital
      ANSELA = 0;
   
      PORTD = 0;
      PORTB = 0; 
      PORTA = 0; 

      TRISA = 0x07;
      TRISD = 0x00;		
      TRISB = 0x00;
   
      INTCONbits.GIEH=0;	//Val 0 pq inicialment no s'ha de cridar a la rsi(degut status init)
      INTCONbits.TMR0IF=0;
      INTCONbits.TMR0IE=1; 	//TMR0 enabled
      INTCON2bits.TMR0IP=1; 	//TMR0 Prio enabled (TMR0 always highPrio)
      TMR0=18661;		//2^16 - 46875 (preescaler = 128)
   
  
      T0CONbits.TMR0ON=0;  	//TMR0 OFF
      T0CONbits.T08BIT=0;  	//TMR0 16bits
      T0CONbits.T0CS=0;    	//fosc/4
      T0CONbits.PSA=0;		//prescaler on
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
      
      PR2 = 3036;
      T2CON=0x2B; 		//PRE = 16, POST = 6 --> 3*(1/(16*6)/2x10^6)) = 62500 < 2^16 //2B
      IPR1bits.TMR2IP = 1;
      PIE1bits.TMR2IE = 1;
      PIR1bits.TMR2IF = 0;
      
      /*
      PR2=256;
      T2CON=0xFF;
      IPR1bits.TMR2IP = 0;
      PIE1bits.TMR2IE = 1;
      PIR1bits.TMR2IF = 0;
      */

      ADCON0 = 0x09;
      ADCON1 = 0x00;
      ADCON2 = 0b10100100;
}




void configUSART() {
      /*
      TRISCbits.RC6 = 0;	// Configurem RC6 de sortida (transmissió)
      TRISCbits.RC7 = 1;	// Configurem RC7 d'entrada (recepció)
   
      TXSTA1bits.TX9 = 0;
      TXSTA1bits.SYNC = 0;
      TXSTA1bits.BRGH = 1;
      BAUDCON1bits.BRG16 = 0;
      SPBRG1 = 16;
      TXSTA1bits.TXEN = 1;
      RCSTA1bits.RX9 = 0;
      RCSTA1bits.SREN = 1;
      RCSTA1bits.SPEN = 1;
      */
   
      SPBRG1 =3;
      TXSTA1bits.BRGH = 1;
      TXSTA1bits.TX9 = 0;
      TXSTA1bits.TXEN = 1;
      RCSTA1bits.SREN = 1;
      RCSTA1bits.SPEN = 1;
      RCSTA1bits.RX9 = 0;
      BAUDCON1bits.BRG16 = 1;
      TRISC = 0xFF;
      PIE1bits.RC1IE = 1;
      IPR1bits.RC1IP = 1;
      TXSTA1bits.SYNC = 0;
      RCSTA1bits.CREN = 1;
}

void main(void) {
   configPIC();
   //configUSART();
   
   GLCDinit();
   clearGLCD(0,7,0,127);
   setStartLine(0);
   welcome();
   INTCONbits.GIEH=1;
   T0CONbits.TMR0ON=1;  		//TMR0 ON
   //puts_usart1(s);
   while (1) {
      if(IntroOver == 1) {
	 IntroOver = 0;
	 clearGLCD(0,7,0,127);
	 setStartLine(0);
	 initialize_game();
      }
      if(StartGame == 1) {
	 Game();
      }
   }
}

DEFINITIVE

/* Main.c file generated by New Project wizard
 *
 * Created:   Mon Dec 21 2020
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */


#include <xc.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#include "GLCD.h"
#include "splash.h"
#include "ascii.h"

#define _XTAL_FREQ 8000000 


#define GO_DONE ADCON0bits.GO
#define PINA0 PORTAbits.RA0
#define PINA1 PORTAbits.RA1

//CONTROL
int IntroOver = 0;
char StartGame = 0;
int YesNo = 0;
char END = 0;
char generate_pic = 0;
char move_pic = 0;

//PICS & PLAYER
int PosXPICs[100];
int PosYPICs[100] = 0;
int actualPics = 1;
char posX = 5;

//DIFFICULTY
int old_difficulty = 1;
int new_difficulty = 1;

//AD
int status_old = 0;
int status_new = 0;

//VALUES
int PrePts = 0, PostPts = 0;
int PreLives = 3, PostLives = 3;

//EXTRA
unsigned char s[6] = "Ricard";
const char * c = "#";
const char * v = "$";


//INTERRUPT ROUTINES

void interrupt HighInt(void) {
   if(INTCONbits.TMR0IE && INTCONbits.TMR0IF && PostLives > 0 && !END) {
      INTCONbits.TMR0IF=0;
      if(StartGame == 0) {
	 IntroOver = 1;
	 StartGame = 1;
      } else {
	 ++YesNo;
	 generate_pic = 1;
      }
   }
   if(PIE1bits.TMR2IE && PIR1bits.TMR2IF && StartGame && PostLives > 0 && !END){
      move_pic = 1;
   }
}

//ENDING SCREEN & RESULTS

void end_game() {
   writeTxt(5,6, "PICs Collected");
   writeTxt(3,7,"Game Over!");
   writeNum(5,4,PostPts);
   END = 1;
}

//PRINT IN-GAME POINTS & LIVES

void printData(){
   if(PrePts != PostPts) writeNum(0,5,PostPts);
   if(PreLives != PostLives || PostLives == 3) {
      int i = 1, j = 2;
      if(PostLives == 3) {
	 while(i <= 3) {
	 putchGLCD(0,18+j,126);
	 j = j+2;
	 ++i;
	 }
      } else if (PostLives == 2) {
	 clearGLCD(0,0,120,126);
      } else if (PostLives == 1) {
	 clearGLCD(0,0,110,122);
      } else {
	 clearGLCD(0,0,100,110);
	 __delay_ms(250); 
	 clearGLCD(0,7,0,127);
	 end_game();
      }
   }
}

//PLAYER MOVEMENT SET

void player_movements() {
   if(PINA0 == 1 && posX < 24){
      clearGLCD(7,7,posX,5+posX*5);
      ++posX;
      writeTxt(7,posX,c);	
      __delay_ms(250); 
   } else if(PINA1 == 1 && posX > 0){
      clearGLCD(7,7,posX,5+posX*5);
      --posX;
      writeTxt(7,posX,c);
      __delay_ms(250);
   }
}

//DIFFICULTY LEVELS

void calc_difficulty(int value) {
   if(value < 300) {
      new_difficulty = 1;
      TMR0=18661;		//3 s 
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
   } else if (value > 300 && value < 550) {
      new_difficulty = 2;
      TMR0=18661;		//3 s
      T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
   } else if (value > 550 && value < 800) {
      new_difficulty = 3;
      TMR0=3036;		//1 s
      T0CONbits.T0PS=0b100;	//prescaler = 32 -> 46875 < 2^16 //0b110
   } else if (value > 800) {
      new_difficulty = 4;
      TMR0=3036;		//0.5 s
      T0CONbits.T0PS=0b011;	//prescaler = 16-> 46875 < 2^16 //0b110
   }
   if(new_difficulty != old_difficulty) {
      old_difficulty = new_difficulty;
      writeNum(0,11,new_difficulty);
   }
}

//CHECKING AD VALUES

void check_AD() {
   GO_DONE = 1;
   while(GO_DONE) {
      status_old = status_new;
      status_new = ADRESH*256 + ADRESL;
      if(status_old != status_new) calc_difficulty(status_new);
   }
}

//PICs GENERATOR

void generate_pics() {
   if(new_difficulty == 1 && YesNo == 3) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   } else if(new_difficulty == 2 && YesNo == 2) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   } else if(new_difficulty == 3 && YesNo == 3) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   } else if(new_difficulty == 4 && YesNo == 2) {
      YesNo = 0;
      ++actualPics;
      if(PosYPICs[actualPics] == 0) {
	 PosYPICs[actualPics] = 1;
	 PosXPICs[actualPics] = rand() % 24;
	 writeTxt(PosYPICs[actualPics],PosXPICs[actualPics], v);
      }
   }
}

//PICs MOVEMENT

void move_pics() {
   for (int j=0;j<=actualPics;j++) {
      if(PosXPICs[j] != -1 && PosYPICs[j] != 0){
	 clearGLCD(PosYPICs[j],PosYPICs[j],PosXPICs[j],5+(PosXPICs[j])*5);
	 PosYPICs[j] = PosYPICs[j] + 1;
	 if(PosXPICs[j] == posX && PosYPICs[j] == 7){ 
	    PosXPICs[j] = -1;
	    PosYPICs[j] = -1;
	    //--actualPics
	    PostPts++;
	 } else if(PosYPICs[j] == 7) {
	    PosXPICs[j] = -1;
	    PosYPICs[j] = -1;
	    //--actualPics;
	    --PostLives;
	 } else writeTxt(PosYPICs[j],PosXPICs[j],v);
      }
   }  
}

//PICs MANAGEMENT

void pics_management() {
   if(generate_pic) {
      generate_pic = 0;
      generate_pics();
   }
   if(move_pic) {
      move_pic = 0;
      move_pics();
   }
}

//GAME

void Game() { 
   if(!END) {
      check_AD();
      printData();
      player_movements();
      pics_management();
   }
}

//INITIAL GAME SETTINGS

void initialize_game() {
   T0CONbits.TMR0ON = 1;  	//TMR0 ON
   T2CONbits.TMR2ON = 1;  	//TMR2 ON
   writeTxt(0,0," Pts:");
   writeTxt(0,13, "Lives:");
   writeTxt(0,7,"Dif:");
   writeNum(0,5,PostPts);
   writeNum(0,11,new_difficulty);
   writeTxt(7,posX,c);	
   PosYPICs[0] = 1;
   PosXPICs[0] = rand() % 24;
   writeTxt(PosYPICs[0],PosXPICs[0], v);
}

//USART

void putc_usart1(char xc) {
   while(!PIR1bits.TX1IF);
   TXREG1 = xc;
}

void puts_usart1(unsigned char *cptr) {
   while(*cptr) {
      putc_usart1(*cptr++);
   }
}

//INTRO SCREEN

void Intro() {
   for(int i = 0; i < 8; ++i) {
      for(int j = 0; j < 128; ++j) {
	 writeByte(i, j, bitmap[i * 128 + j]);
      }
   }
}


void configPIC() {
   
   //DIGITAL / ANALOG
   
   ANSELD = 0;
   ANSELB = 0;
   ANSELC = 0;
   ANSELA = 0x04;		//AD READINGS
   
   PORTD = 0;
   PORTB = 0;
   PORTA = 0;

   //INPUT / OUTPUT
   
   TRISA = 0x07;		//Buttons & AD
   TRISD = 0x00;
   TRISB = 0x00;
   
   //INTERRUPTS & TMR0
   
   INTCONbits.GIEH=0;		//Val 0 pq inicialment no s'ha de cridar a la rsi
   INTCONbits.TMR0IF=0;
   INTCONbits.TMR0IE=1; 	//TMR0 enabled
   INTCON2bits.TMR0IP=1; 	//TMR0 Prio enabled (TMR0 always highPrio)
   TMR0=18661;			//2^16 - 46875 (preescaler = 128)
   
   T0CONbits.TMR0ON=0;  	//TMR0 OFF
   T0CONbits.T08BIT=0;  	//TMR0 16bits
   T0CONbits.T0CS=0;    	//fosc/4
   T0CONbits.PSA=0;		//prescaler on
   T0CONbits.T0PS=0b110;	//prescaler = 128 -> 46875 < 2^16 //0b110
   
   //INTERRUPTS & TMR2

   PR2 = 3036;
   T2CON=0x2B; 			//PRE = 16, POST = 6 --> 3*(1/(16*6)/2x10^6)) = 62500 < 2^16 //2B
   IPR1bits.TMR2IP = 1;
   PIE1bits.TMR2IE = 1;
   PIR1bits.TMR2IF = 0;

   //AD
   
   ADCON0 = 0x09;
   ADCON1 = 0x00;
   ADCON2 = 0b10100100;
   
   //USART
   
   /*
   TRISCbits.RC6 = 0;	// Configurem RC6 de sortida (transmissió)
   TRISCbits.RC7 = 1;	// Configurem RC7 d'entrada (recepció)
   
   TXSTA1bits.TX9 = 0;
   TXSTA1bits.SYNC = 0;
   TXSTA1bits.BRGH = 1;
   BAUDCON1bits.BRG16 = 0;
   SPBRG1 = 16;
   TXSTA1bits.TXEN = 1;
   RCSTA1bits.RX9 = 0;
   RCSTA1bits.SREN = 1;
   RCSTA1bits.SPEN = 1;
   */
   
   SPBRG1 =3;
   TXSTA1bits.BRGH = 1;
   TXSTA1bits.TX9 = 0;
   TXSTA1bits.TXEN = 1;
   RCSTA1bits.SREN = 1;
   RCSTA1bits.SPEN = 1;
   RCSTA1bits.RX9 = 0;
   BAUDCON1bits.BRG16 = 1;
   TRISC = 0xFF;
   PIE1bits.RC1IE = 1;
   IPR1bits.RC1IP = 1;
   TXSTA1bits.SYNC = 0;
   RCSTA1bits.CREN = 1;
   
}

void main(void) {
   configPIC();   
   GLCDinit();
   clearGLCD(0,7,0,127);
   setStartLine(0);
   
   Intro();
   INTCONbits.GIEH=1;
   T0CONbits.TMR0ON=1;  	//TMR0 ON
   //puts_usart1(s);
   while (1) {
      if(IntroOver == 1) {
	 IntroOver = 0;
	 clearGLCD(0,7,0,127);
	 setStartLine(0);
	 initialize_game();
      }
      if(StartGame == 1) Game();
      if(END) end_game();
   }
}