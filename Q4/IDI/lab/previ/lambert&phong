#version 330 core

in vec3 vertex;
in vec3 normal;

in vec3 matamb;
in vec3 matdiff;
in vec3 matspec;
in float matshin;

uniform mat4 proj;
uniform mat4 view;
uniform mat4 TG;

// Valors per als components que necessitem dels focus de llum
vec3 colFocus = vec3(1., 1., 1.);
vec3 llumAmbient = vec3(0.2, 0.2, 0.2);
vec3 posFocus = vec3(1, 1, 1);  // en SCA

out vec3 fcolor;

vec3 Lambert (vec3 NormSCO, vec3 L) 
{
    // S'assumeix que els vectors que es reben com a paràmetres estan normalitzats

    // Inicialitzem color a component ambient
    vec3 colRes = llumAmbient * matamb;

    // Afegim component difusa, si n'hi ha
    if (dot (L, NormSCO) > 0)
      colRes = colRes + colFocus * matdiff * dot (L, NormSCO);
    return (colRes);
}

vec3 Phong (vec3 NormSCO, vec3 L, vec4 vertSCO) 
{
    // Els vectors estan normalitzats

    // Inicialitzem color a Lambert
    vec3 colRes = Lambert (NormSCO, L);

    // Calculem R i V
    if (dot(NormSCO,L) < 0)
      return colRes;  // no hi ha component especular

    vec3 R = reflect(-L, NormSCO); // equival a: normalize (2.0*dot(NormSCO,L)*NormSCO - L);
    vec3 V = normalize(-vertSCO.xyz);

    if ((dot(R, V) < 0) || (matshin == 0))
      return colRes;  // no hi ha component especular
    
    // Afegim la component especular
    float shine = pow(max(0.0, dot(R, V)), matshin);
    return (colRes + matspec * colFocus * shine); 
}

void main()
{	
	// Passar posicio del vertex a SCO
	vec3 vertSCO = (view * TG * vec4(vertex, 1.0)).xyz;
	
	// Pasar posicio del focus de llum en SCO
	vec3 posF = (view * vec4(posFocus, 1.0)).xyz;
	
	// Direccio llum
	vec3 L = posF - vertSCO;
	
	// Passar vector normal a SCO
	mat3 NormalMatrix = (inverse(transpose(mat3(view * TG))));
	vec3 NM = NormalMatrix * normal;
	
	// Nomes la Normal i la L son "vcectors", els unics que es normalitzen
	L = normalize(L);
	NM = normalize(NM);
	
//    fcolor = Lambert(NM, L);
    fcolor = Phong(NM, L, vec4(vertSCO, 1.));
    gl_Position = proj * view * TG * vec4 (vertex, 1.0);
}


//MATERIALS:

Al crear el buffer: 

  // Definim el material del terra
  glm::vec3 amb(0.2,0,0.2);
  glm::vec3 diff(0,0,0.8);
  glm::vec3 spec(1,1,1);
  float shin = 100;
  
Modificar parametres iluminació des de MyGLWidget?
  
  	1- Definir al .h i al vertex shader els parametres en qüestió.
  		
  		GLuint posFocusLoc, colFocusLoc; 	//MyGLWidget.h
  		uniform vec3 posFocus; 			//VertexShader
		uniform vec3 colFocus;			//VertexShader
  	
  	2- Al inicialitzar (initialize()), passar-los al uniform:
  	
	  	glm::vec3 posFocus = glm::vec3(posFocusX, 0, 1);
	  	glUniform3fv(posFocusLoc, 1, &posFocus[0]);
  		glm::vec3 colFocus = glm::vec3(0.8, 0.8, 0.8);
		glUniform3fv(colFocusLoc, 1, &colFocus[0]);
		
	3- Al carregar shaders (carregaShaders()), afagar-los del vertex shader:
	  	
	  	posFocusLoc = glGetUniformLocation (program->programId(), "posFocus");
		colFocusLoc = glGetUniformLocation (program->programId(), "colFocus");
		
	4- Programar el keyPressEvent:
	
		switch (event->key()) {
			case Qt::Key_O: { // canvia òptica entre perspectiva i axonomètrica
				perspectiva = !perspectiva;
				projectTransform ();
				break;
			}
			case Qt::Key_K: {
				if(posFocusX >= -2) {
					posFocusX -= 0.2;
					glm::vec3 posFocus = glm::vec3(posFocusX, 0, 1);
					glUniform3fv(posFocusLoc, 1, &posFocus[0]);
				}
				break;
			}
			case Qt::Key_L: {
				if(posFocusX <= 2) {
					posFocusX += 0.2;
					glm::vec3 posFocus = glm::vec3(posFocusX, 0, 1);
					glUniform3fv(posFocusLoc, 1, &posFocus[0]);
				}
				break;
			}
		    default: event->ignore(); break;
		}
		
		
RESIZE FUNCTION:

void MyGLWidget::resizeGL (int w, int h) 
{
  ra = float(w)/float(h);
  if (ra < 1) fov = 2.0 * atan(tan(asin(0.5f))/ra);
  projectTransform ();
}

MODIFICACIÓ viewTransform() i projectTransform() per tal de mantenir l'escena central i aprofitar el viewport:

#IniEscena:
  	radiEsc = sqrt((maxx-minx)*(maxx-minx)+(maxy-miny)*(maxy-miny)+(maxz-minz)*(maxz-minz))/2.f;


// PINTA A FRANGES

    //if ((int(gl_FragCoord.y) % 20) <= 10) FragColor= vec4(1.0, 1.0, 1.0, 1.0);
    //else FragColor= vec4(0, 0, 0, 1.0);
    
//IL·LUMINACIÓ AL FRAGMENT SHADER:

	1. Calcular focusSCO: 	#vec4 focusSCO = vec4(posFocus, 1.0);
	2. Calcular LSCO: 	#vec3 LSCO = normalize(focusSCO.xyz-vertexSCO.xyz);
	3. Call Phong: 		#vec3 color = Phong(normalSCO, LSCO, vertexSCO);
	4. Assignar color: 	#FragColor = vec4(color, 1);

